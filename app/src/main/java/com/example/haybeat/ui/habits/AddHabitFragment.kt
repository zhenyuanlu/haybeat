package com.example.haybeat.ui.habits

import android.os.Bundle
import android.text.Editable // Import TextWatcher related classes
import android.text.TextWatcher // Import TextWatcher
import android.util.Log
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ArrayAdapter
import android.widget.AutoCompleteTextView
import android.widget.Toast
import androidx.activity.addCallback
import androidx.appcompat.app.AlertDialog
import androidx.core.content.ContextCompat
import androidx.core.view.children
import androidx.core.view.isVisible
import androidx.fragment.app.Fragment
import androidx.fragment.app.viewModels
import androidx.navigation.fragment.findNavController
import androidx.navigation.fragment.navArgs // Import navArgs delegate
import androidx.navigation.ui.NavigationUI
import com.example.haybeat.R
import com.example.haybeat.data.model.Habit
import com.example.haybeat.databinding.FragmentAddHabitBinding
import com.example.haybeat.service.AlarmScheduler
import com.google.android.material.chip.Chip
import com.google.android.material.timepicker.MaterialTimePicker
import com.google.android.material.timepicker.TimeFormat
import java.text.SimpleDateFormat // Keep this for formatting display time
import java.util.*
import kotlin.collections.set

class AddHabitFragment : Fragment() {

    private var _binding: FragmentAddHabitBinding? = null
    private val binding get() = _binding!!

    private val viewModel: AddHabitViewModel by viewModels()
    // Use the navArgs delegate to get arguments generated by Safe Args
    private val args: AddHabitFragmentArgs by navArgs()

    // State variables
    private var selectedHour: Int? = null
    private var selectedMinute: Int? = null
    private var selectedColorHex: String = "#FF14B8A6" // Default Teal (Matches XML default chip)
    private var currentHabit: Habit? = null // The habit being edited
    private var hasUnsavedChanges: Boolean = false

    // Fixed data for UI elements
    private val categories = listOf("Mindfulness", "Learning", "Fitness", "Health", "Career", "Chores", "Social", "Other")
    private val habitColorsMap = mapOf(
        R.id.chip_color_teal to "#FF14B8A6",
        R.id.chip_color_blue to "#FF3B82F6",
        R.id.chip_color_green to "#FF22C55E",
        R.id.chip_color_amber to "#FFF59E0B",
        R.id.chip_color_indigo to "#FF6366F1",
        R.id.chip_color_red to "#FFEF4444"
    )

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentAddHabitBinding.inflate(inflater, container, false)
        // Handle system back press: check for unsaved changes
        requireActivity().onBackPressedDispatcher.addCallback(viewLifecycleOwner) {
            handleBackPress()
        }
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)

        setupToolbar()
        setupCategoryDropdown()
        setupFrequencyControls()
        setupReminderControls()
        setupColorPicker()
        setupSaveButton()
        setupDeleteButton()
        observeViewModel()
        addChangeListeners() // Add listeners AFTER potentially populating form

        // Trigger loading the habit if an ID was passed
        viewModel.loadHabit(args.habitId) // Use habitId from Safe Args

    }

    // --- Setup Functions ---

    private fun setupToolbar() {
        val toolbarTitle = if (args.habitId == null) {
            getString(R.string.new_habit) // Title for adding
        } else {
            getString(R.string.edit_habit) // Title for editing
        }
        binding.toolbar.title = toolbarTitle


        // Connect toolbar "Up" button to NavController
        NavigationUI.setupWithNavController(binding.toolbar, findNavController())
        // Override Up button default behavior to check for unsaved changes
        binding.toolbar.setNavigationOnClickListener { handleBackPress() }
    }

    private fun setupCategoryDropdown() {
        val adapter = ArrayAdapter(requireContext(), android.R.layout.simple_dropdown_item_1line, categories)
        (binding.categoryLayout.editText as? AutoCompleteTextView)?.setAdapter(adapter)
    }

    private fun setupFrequencyControls() {
        binding.frequencyRadioGroup.setOnCheckedChangeListener { _, checkedId ->
            binding.weeklyGoalLayout.isVisible = checkedId == R.id.radio_weekly
            binding.specificDaysChipGroup.isVisible = checkedId == R.id.radio_specific_days
            markAsChanged()
        }
        binding.specificDaysChipGroup.setOnCheckedStateChangeListener { _, _ -> markAsChanged() }
    }

    private fun setupReminderControls() {
        binding.setReminderButton.setOnClickListener {
            showTimePicker()
            // Change will be marked when time is actually selected via updateReminderText -> markAsChanged
        }
        binding.clearReminderButton.setOnClickListener {
            clearReminder()
            markAsChanged()
        }
    }

    private fun setupColorPicker() {
        // Assign hex color string as the tag for each color chip
        habitColorsMap.forEach { (chipId, colorHex) ->
            binding.root.findViewById<Chip>(chipId)?.tag = colorHex
        }

        binding.colorChipGroup.setOnCheckedStateChangeListener { group, checkedIds ->
            if (checkedIds.isNotEmpty()) {
                val selectedChip = group.findViewById<Chip>(checkedIds.first())
                selectedColorHex = selectedChip?.tag as? String ?: habitColorsMap.values.first()

                // Visual feedback: Adjust stroke width on selection
                group.children.filterIsInstance<Chip>().forEach { chip ->
                    chip.chipStrokeWidth = if (chip.isChecked) 6f else 2f // Use isChecked
                }
                markAsChanged()
            }
        }
    }

    private fun setupSaveButton() {
        binding.saveButton.setOnClickListener {
            if (collectAndValidateHabitData()) { // Validate first
                saveHabitData()
            }
        }
    }

    private fun setupDeleteButton() {
        binding.deleteButton.setOnClickListener {
            showDeleteConfirmation()
        }
    }

    // Add simple TextWatcher or FocusChangeListeners to inputs
    private fun addChangeListeners() {
        val textWatcher = object : TextWatcher {
            override fun beforeTextChanged(s: CharSequence?, start: Int, count: Int, after: Int) {}
            override fun onTextChanged(s: CharSequence?, start: Int, before: Int, count: Int) { markAsChanged() }
            override fun afterTextChanged(s: Editable?) {}
        }
        binding.habitNameEditText.addTextChangedListener(textWatcher)
        binding.categoryAutocomplete.addTextChangedListener(textWatcher) // Detect category changes
        binding.weeklyGoalEditText.addTextChangedListener(textWatcher)
        // ChipGroup and RadioGroup changes are handled by their specific listeners above
    }

    private fun markAsChanged() {
        if (!hasUnsavedChanges) { // Mark only once per fragment lifecycle unless saved/loaded
            Log.d("AddHabitFragment", "Change detected.")
        }
        hasUnsavedChanges = true
    }


    // --- ViewModel Observation ---

    private fun observeViewModel() {
        viewModel.habitToEdit.observe(viewLifecycleOwner) { habit ->
            currentHabit = habit // Store the loaded habit
            populateForm(habit)
            binding.deleteButton.isVisible = habit != null // Show delete only in edit mode
            hasUnsavedChanges = false // Reset change tracker after loading/populating
            Log.d("AddHabitFragment", "Observed habitToEdit: ${habit?.id ?: "null"}. Resetting unsaved changes.")
        }

        viewModel.modifyResult.observe(viewLifecycleOwner) { result ->
            binding.loadingProgressBar.isVisible = result is HabitModifyResult.Loading
            binding.saveButton.isEnabled = result !is HabitModifyResult.Loading
            binding.deleteButton.isEnabled = result !is HabitModifyResult.Loading

            when (result) {
                is HabitModifyResult.Success -> {
                    hasUnsavedChanges = false // Mark changes as saved/processed
                    val habitJustSaved = viewModel.habitToEdit.value ?: currentHabit // Get potentially updated habit data
                    scheduleOrCancelReminder(habitJustSaved) // Schedule based on final state

                    val message = if (binding.deleteButton.isVisible && currentHabit != null) "Habit updated" else getString(R.string.habit_saved)
                    Toast.makeText(context, message, Toast.LENGTH_SHORT).show()
                    findNavController().popBackStack() // Navigate back
                }
                is HabitModifyResult.Error -> {
                    Toast.makeText(context, "Error: ${result.message}", Toast.LENGTH_LONG).show()
                }
                else -> { /* Loading state handled by visibility toggle */ }
            }
        }
    }

    // --- UI Population and Data Handling ---

    private fun populateForm(habit: Habit?) {
        if (habit == null) { // Add Mode - Set Defaults
            binding.categoryAutocomplete.setText(categories.last(), false)
            binding.priorityChipGroup.check(R.id.chip_priority_medium)
            binding.frequencyRadioGroup.check(R.id.radio_daily)
            binding.weeklyGoalLayout.isVisible = false
            binding.specificDaysChipGroup.isVisible = false
            binding.specificDaysChipGroup.clearCheck()
            val defaultColorChipId = R.id.chip_color_teal // Match XML default
            binding.colorChipGroup.check(defaultColorChipId)
            selectedColorHex = habitColorsMap[defaultColorChipId] ?: habitColorsMap.values.first()
            updateColorChipVisuals() // Update stroke
            clearReminder()
            Log.d("AddHabitFragment", "Form populated with defaults for Add mode.")
        } else { // Edit Mode - Populate with Habit data
            Log.d("AddHabitFragment", "Populating form for Edit mode: ${habit.name}")
            binding.habitNameEditText.setText(habit.name)
            binding.categoryAutocomplete.setText(habit.category.takeIf { it.isNotBlank() } ?: categories.last(), false)

            binding.priorityChipGroup.check(when(habit.priority.lowercase()) {
                "high" -> R.id.chip_priority_high
                "low" -> R.id.chip_priority_low
                else -> R.id.chip_priority_medium
            })

            binding.frequencyRadioGroup.check(when (habit.frequencyType) {
                "weekly" -> R.id.radio_weekly.also { binding.weeklyGoalEditText.setText(habit.weeklyGoal.toString()) }
                "specific_days" -> R.id.radio_specific_days.also {
                    binding.specificDaysChipGroup.clearCheck()
                    habit.specificDays?.forEach { dayIndex -> getChipIdFromDayIndex(dayIndex)?.let { binding.specificDaysChipGroup.check(it) } }
                }
                else -> R.id.radio_daily
            })
            // Ensure visibility matches checked state AFTER checking the radio button
            binding.weeklyGoalLayout.isVisible = binding.frequencyRadioGroup.checkedRadioButtonId == R.id.radio_weekly
            binding.specificDaysChipGroup.isVisible = binding.frequencyRadioGroup.checkedRadioButtonId == R.id.radio_specific_days

            if (habit.reminderTime != null) {
                try {
                    val parts = habit.reminderTime!!.split(":")
                    selectedHour = parts[0].toInt()
                    selectedMinute = parts[1].toInt()
                    updateReminderText()
                } catch (e: Exception) { clearReminder() }
            } else {
                clearReminder()
            }

            selectedColorHex = habit.colorHex
            val colorChipId = habitColorsMap.entries.find { it.value.equals(habit.colorHex, ignoreCase = true) }?.key ?: R.id.chip_color_teal
            binding.colorChipGroup.check(colorChipId)
            updateColorChipVisuals() // Update stroke
        }
        // Crucial: Reset change tracking AFTER populating the form
        hasUnsavedChanges = false
        Log.d("AddHabitFragment", "Finished populating form. hasUnsavedChanges = $hasUnsavedChanges")
    }

    /** Collects data from UI, validates input, returns true if valid. */
    private fun collectAndValidateHabitData(): Boolean {
        val name = binding.habitNameEditText.text.toString().trim()
        if (name.isEmpty()) {
            binding.habitNameLayout.error = "Habit name cannot be empty"
            binding.habitNameEditText.requestFocus()
            return false
        } else {
            binding.habitNameLayout.error = null
        }

        if (binding.frequencyRadioGroup.checkedRadioButtonId == R.id.radio_specific_days &&
            binding.specificDaysChipGroup.checkedChipIds.isEmpty()) {
            Toast.makeText(context, "Please select at least one specific day", Toast.LENGTH_SHORT).show()
            return false
        }

        if (binding.frequencyRadioGroup.checkedRadioButtonId == R.id.radio_weekly) {
            val weeklyGoalVal = binding.weeklyGoalEditText.text.toString().toIntOrNull()
            if (weeklyGoalVal == null || weeklyGoalVal !in 1..7) {
                Toast.makeText(context, "Weekly goal must be between 1 and 7", Toast.LENGTH_SHORT).show()
                // Optionally set error on TextInputLayout if you wrap the EditText
                binding.weeklyGoalEditText.requestFocus()
                return false
            }
        }
        return true
    }

    /** Assumes validation passed. Creates/updates Habit and calls ViewModel. */
    private fun saveHabitData() {
        val name = binding.habitNameEditText.text.toString().trim()
        val category = binding.categoryAutocomplete.text.toString().takeIf { it.isNotBlank() } ?: categories.last()
        val priority = when (binding.priorityChipGroup.checkedChipId) { R.id.chip_priority_high -> "high"; R.id.chip_priority_low -> "low"; else -> "medium" }
        var frequencyType: String = "daily"; var weeklyGoal: Int = 1; var specificDays: List<Int>? = null

        when (binding.frequencyRadioGroup.checkedRadioButtonId) {
            R.id.radio_weekly -> { frequencyType = "weekly"; weeklyGoal = binding.weeklyGoalEditText.text.toString().toIntOrNull() ?: 1 }
            R.id.radio_specific_days -> { frequencyType = "specific_days"; specificDays = binding.specificDaysChipGroup.checkedChipIds.mapNotNull { getDayIndexFromChipId(it) }.sorted() }
        }
        val reminderTime = if (selectedHour != null && selectedMinute != null) String.format(Locale.US, "%02d:%02d", selectedHour, selectedMinute) else null

        val habitToSave = currentHabit?.copy( // Create a copy if editing
            name = name, category = category, priority = priority, frequencyType = frequencyType,
            weeklyGoal = weeklyGoal, specificDays = specificDays, reminderTime = reminderTime, colorHex = selectedColorHex
        ) ?: Habit( // Create new if not editing
            name = name, category = category, priority = priority, frequencyType = frequencyType,
            weeklyGoal = weeklyGoal, specificDays = specificDays, reminderTime = reminderTime, colorHex = selectedColorHex
        )
        viewModel.saveHabit(habitToSave)
    }

    // --- UI Helpers ---

    private fun showTimePicker() {
        val calendar = Calendar.getInstance()
        val currentHour = selectedHour ?: calendar.get(Calendar.HOUR_OF_DAY)
        val currentMinute = selectedMinute ?: calendar.get(Calendar.MINUTE)
        val isSystem24Hour = android.text.format.DateFormat.is24HourFormat(context)
        val clockFormat = if (isSystem24Hour) TimeFormat.CLOCK_24H else TimeFormat.CLOCK_12H

        val picker = MaterialTimePicker.Builder().setTimeFormat(clockFormat).setHour(currentHour).setMinute(currentMinute).setTitleText(getString(R.string.select_time)).build()
        picker.addOnPositiveButtonClickListener {
            selectedHour = picker.hour
            selectedMinute = picker.minute
            updateReminderText()
            markAsChanged() // Explicitly mark change after selection
        }
        picker.show(childFragmentManager, "time_picker_tag")
    }

    private fun updateReminderText() {
        if (selectedHour != null && selectedMinute != null) {
            val calendar = Calendar.getInstance().apply { set(Calendar.HOUR_OF_DAY, selectedHour!!); set(Calendar.MINUTE, selectedMinute!!) }
            val timeFormat = SimpleDateFormat("h:mm a", Locale.getDefault()) // Standard 12-hour format AM/PM
            binding.reminderTimeText.text = timeFormat.format(calendar.time)
            binding.reminderTimeText.setTextColor(ContextCompat.getColor(requireContext(), R.color.grey_800)) // Or use theme color
            binding.clearReminderButton.isVisible = true
        }
    }

    private fun clearReminder() {
        selectedHour = null; selectedMinute = null
        binding.reminderTimeText.text = getString(R.string.no_reminder)
        binding.reminderTimeText.setTextColor(ContextCompat.getColor(requireContext(), R.color.grey_400))
        binding.clearReminderButton.isVisible = false
    }

    private fun updateColorChipVisuals() {
        binding.colorChipGroup.post { // Ensure chips are laid out
            val checkedId = binding.colorChipGroup.checkedChipId
            binding.colorChipGroup.children.filterIsInstance<Chip>().forEach { chip ->
                chip.chipStrokeWidth = if (chip.id == checkedId) 6f else 2f
            }
        }
    }

    // --- Dialogs ---

    private fun showDeleteConfirmation() {
        currentHabit?.let { habitToDelete ->
            AlertDialog.Builder(requireContext())
                .setTitle(R.string.confirm_delete_habit)
                .setMessage(getString(R.string.delete_habit_message, habitToDelete.name))
                .setIcon(R.drawable.ic_delete)
                .setPositiveButton(R.string.delete) { _, _ -> viewModel.deleteHabit(habitToDelete) }
                .setNegativeButton(R.string.cancel, null).show()
        }
    }

    private fun handleBackPress() {
        if (hasUnsavedChanges) {
            showUnsavedChangesDialog()
        } else {
            findNavController().popBackStack() // Navigate back normally
        }
    }

    private fun showUnsavedChangesDialog() {
        AlertDialog.Builder(requireContext())
            .setTitle(R.string.unsaved_changes)
            .setMessage("Discard your changes?")
            .setPositiveButton(R.string.discard) { _, _ -> findNavController().popBackStack() } // Discard and go back
            .setNegativeButton(R.string.cancel, null) // Stay on screen
            .show()
    }

    // --- Alarm Scheduling ---

    private fun scheduleOrCancelReminder(savedHabit: Habit?) {
        val habitId = savedHabit?.id?.takeIf { it.isNotBlank() } ?: return // Need valid ID
        val habitName = savedHabit.name

        if (savedHabit.reminderTime != null && selectedHour != null && selectedMinute != null) {
            Log.d("AddHabitFragment", "Scheduling reminder for $habitId at $selectedHour:$selectedMinute")
            AlarmScheduler.scheduleHabitReminder(requireContext(), habitId, habitName, selectedHour!!, selectedMinute!!)
        } else {
            Log.d("AddHabitFragment", "Canceling reminder for $habitId")
            AlarmScheduler.cancelHabitReminder(requireContext(), habitId)
        }
    }

    // --- Helpers ---

    private fun getDayIndexFromChipId(chipId: Int): Int? { /* ... same as before ... */
        return when (chipId) { R.id.chip_day_mon -> 1; R.id.chip_day_tue -> 2; R.id.chip_day_wed -> 3; R.id.chip_day_thu -> 4; R.id.chip_day_fri -> 5; R.id.chip_day_sat -> 6; R.id.chip_day_sun -> 7; else -> null }
    }
    private fun getChipIdFromDayIndex(dayIndex: Int): Int? { /* ... same as before ... */
        return when (dayIndex) { 1 -> R.id.chip_day_mon; 2 -> R.id.chip_day_tue; 3 -> R.id.chip_day_wed; 4 -> R.id.chip_day_thu; 5 -> R.id.chip_day_fri; 6 -> R.id.chip_day_sat; 7 -> R.id.chip_day_sun; else -> null }
    }

    // --- Lifecycle ---
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null // Clean up binding
    }
}